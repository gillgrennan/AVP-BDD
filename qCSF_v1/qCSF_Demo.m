function qcsf = qCSF_Demo%QCSF_DEMO       Demo of the quick CSF (qCSF) method %       %       Lesmes, Lu, Baek, & Albright (2010). Bayesian Adaptive %       Estimation of Contrast Sensitivity Functions: %       the quick CSF (qCSF) method, Journal of Vision  %       http://www.journalofvision.org/10/3/17/%% This demo (version 1.0) compatible with MATLAB 6.0 -- Release 12. It has not % been tested on earlier versions. The most recent version tested is 7.7.0.471% (R2008b). % % Copyright 2009/2010 - Luis Andres Lesmes and Zhong-Lin Lu.% Any reports of bugs or problems, or any comments or requests for additional % features should be sent to Lu Lesmes (lu@salk.edu).%% The quick CSF (qCSF) method is a sequential testing procedure that% applies Bayesian adaptive inference to rapidly estimate the contrast% sensitivity function. The method estimates a functional form of the CSF% (the truncated log-parabola; Watson & Ahumada, 2005) that is defined by % four parameters: (1) peak gain (2) peak frequency (3) bandwidth (full width% at half maximum - FWHM - in octaves, and (4) truncation level on the low-% frequency side. %  % The qCSF's two critical and complementary components are (1) a CSF parameter% space, over which we'll defined a 4-D probability distribution, and (2) a % grating stimulus space, which defines a 2-D grid of spatial frequencies and% contrasts for CSF testing.% % The simple goal of the qCSF is to improve the information gained in the% CSF parameter space through efficient sampling of the grating stimulus% space. On a trial-by-trial basis this is done using a one-step-ahead% search, which evaluates the next trial's possible outcomes to possible% grating stimuli, and chooses the stimulus maximizing the expected% information gain about qCSF parameters.% % %*************************************************************************** % To streamline the consolidation of the qCSF code into your own, we% hide most of the algorithm's nuts and bolts in a structure variable% called 'qcsf'. Several important functions that are called every trial,% that implement pre- and post-trial analyses or plot the results of% simulations or experiments, are called as subfunctions from 'runQCSF.m' .% The qcsf variable is passed to and returned from runQCSF.m:%%% Examples of calling these functions are:% %      runQCSF(qcsf,'pretrial'); % Pre-trial analysis%  %      runQCSF(qcsf,'posttrial',response); % Update qCSF estimates%                                                 based on the observer's response: %                                                 correct(response=1) %                                                 or incorrect(response=0) % %      runQCSF(qcsf,'plot experiment');     % Plots expt results %     %%% Examples of calling runQCSF.m that are exclusive to simulations are: %%      runQCSF(qcsf,'simulate'); % A weighted coin-flip is used to%                                       simulate the observer's response%  %      runQCSF(qcsf,'plot simulation'); % Plots simulation results %    %%% More details about proper input/output syntax for these functions are % available in the comments of the body (see below).%%**************************************************************************% To setup the critical components of the qCSF,the following functions% are called once at the beginning of a qCSF simulation or experiment. % %% setupQCSF.m% setupSimulation.m% setupPriors.m%% For more details, please check these programs for help and other comments.% Another useful function is findQCSF.m, which translates the four CSF% parameters to a sensitivity function defined over a vector of spatial% frequencies. Please enter 'help findQCSF.m' for more details% ***********************************************************************clear all;qcsf = setupQCSF;% **************************************************************************% This program initializes the qcsf variable and sets up (1)the stimulus% space of possible gratings and (2) the parameter space for Bayesian% adaptive inference and (3) experimental factors specific to your experimental% design (e.g., the guess rate for multiple-alternative forced choice and the lapse% rate for finger or inattention errors. % Other factors pertain to the pre-trial% stimulus selection algorithm, which includes the number of Monte Carlo% samples to use to approximate     % Features of the stimulus space are completely% determined by your specific experimental setup: range of stimulus% contrasts and the range of spatial frequencies. Features of the parameter% space and the pre-trial stimulus selection depend on your processing power. Please% see the file's comments for more details.%%%% setupQCSF.m outputs the % qcsf structure with three fields: %% qcsf = % %        stimuli: [1x1 struct]%     parameters: [1x1 struct]%           data: [1x1 struct]% %  ************************************************************************numTrials = 100;    % Setup the number of trials for the experiment or simulation.%qcsf = setupSimulation(qcsf,numTrials); % For an experiment, comment this line out% *************************************************************************** % In an experiment, a real observer is generating responses. For a% simulation, setupSimulation.m is used to set up the simulation's length% (numTrials) and the simulated observer's model CSF. A dialog box can be% used to input the four model CSF parameters. Alternatively, to bypass the% dialog box, the four CSF parameters can be passed to setupSimulation.m as% a vector, [peak-gain peak-frequency bandwidth low-frequency-truncation]%% Example:%%       qcsf = setupSimulation(qcsf,numTrials,[200 3 2.5 .25]); or %       %       qcsf = setupSimulation(qcsf,numTrials); to enter via dialog box%%% After calling setupSimulation.m, the structure variable qcsf should have four fields:%%% qcsf =  %        stimuli: [1x1 struct]%     parameters: [1x1 struct]%     simulation: [1x1 struct]%           data: [1x1 struct]%% The model CSF is contained in qcsf.simulation.trueCSF.% For a real experiment, the qcsf structure does not have the 'simulation' field.%  **************************************************************************qcsf = setupPriors(qcsf,[100 2 3 .5]); %  ************************************************************************% In addition to the qcsf structure variable, the input to setupPriors.m % is a vector with the most likely values (marginal modes) of the four CSF parameters.% Alternatively, calling setupPrior.m without a vector of parameter guesses % pops up a dialog box that collects this information from the user.% %     Example:%    %       qcsf = setupPriors(qcsf); %use a dialog box insted of entering prior modes.% % Please type 'help setupPriors.m' or read that program's file for more% details.%  ************************************************************************% To make it easy to enter different priors independent of setupQCSF.m, we've % moved initialization of the prior to its own program, setupPriors.m.% The setupPriors program could realistically be placed inside setupQCSF, but we% assume users might want to change priors more often than they change the% experimental conditions affecting qCSF setup.  % For example, when measuring spatial CSFs at different temporal frequencies, you% can expect the CSF peak's frequency to decrease and the bandwidth to increase with% increasing temporal frequency. So you can call setupQCSF one time and pass different % copies of the initial qCSF structure (qcsf1,qcsf2) to setupPriors.m, to setup priors% specific to each testing condition. Obviously, it would be critical that% qcsf1 and qcsf2 not contaminate each other in any later calls to runQCSF.m.% Following the calls to setupQCSF.m and setupPriors.m (and setupSimulation.m when% appropriate), the qCSF procedure is ready to to. The loop below simulates the % experiment and presents the updating results in a figure window. for trial = 1:numTrials,    trial,    	 qcsf.data.trial=trial;          % If you are applying more than one qCSF in the same experiment,     % you should update the trial number variable in qcsf.data with     % the trial number for that specific qCSF run, not of the greater     % experiment.         [qcsf,nextFrequency,nextContrast]=runQCSF(qcsf,'pretrial');              % In addition to the qcsf structure, pre-trial analysis returns     % values for the spatial frequency and contrast of the next trial's grating     % stimulus.                                                                               %     [qcsf,response] = runQCSF(qcsf,'simulate',nextFrequency,nextContrast); % For a real experiment,                                                       % comment or delete this line          % For a simulation, the model CSF (qcsf.simulation.trueCSF) generates simulated     % performance (percent correct as a function of grating frequency and     % contrast) using a model psychometric function and a weighted coin     % flip.          % After collecting the observer's response in a real     % experiment,the response variable, coded '1' for a     % correct response or 0 for an incorrect response, is recorded     % in qcsf.data.history, and passed to the post trial     % analysis.          qcsf.data.history(trial,:) = [trial nextFrequency nextContrast response];% updating the experimental history           qcsf=runQCSF(qcsf,'posttrial',nextFrequency,nextContrast,response);          % The post-trial analysis updates the prior density defined over the     % CSF parameter space to the posterior density (which serves as the     % prior for the next trial). The Bayesian update depends on that     % trial's presented stimulus and the recorded response.          %     qcsf=runQCSF(qcsf,'plot simulation');         %     Plots of the qCSF simulation are updated after every trial.In addition to%     the true CSF (black line), the figure's large leftmost panel presents%     each trial's outcome and the subsequently updated qCSF estimate (green%     line). For each simulated trial, the selected grating stimulus is%     presented as a dot, whose color represents a correct (green) or incorrect%     (red) response. The inset presents the results of the qCSF's stimulus%     selection algorithm (the pre-trial calculation of expected information%     gain as a function of grating frequency and contrast), with the updating%     qCSF estimate (white) overlaid as a reference. The right-hand panels%     demonstrate the trial-by-trial Bayesian update of the probability density%     defined over four CSF parameters; in addition to a pair of 2-d marginal%     densities -- defined by peak gain and peak frequency (top), and bandwidth%     and low-frequency truncation (bottom) -- the 1-d marginals for each%     parameter are presented. Overlaid on both 2-D densities are white%     cross-lines which represent the targets of parameter estimation: the%     observer's true CSF parameters. The small white dots represent Monte%     Carlo samples of the probability density, which accelerate the pre-trial%     calculations (see manuscripts's Appendix). At the demo's completion, the main plot's%     inset presents the bias of AULCSF estimates (in %) as a function of trial%     number for the full simulated run. Several features of the demo providing%     evidence for the qCSF's successful convergence are: (1) the overlap of%     the CSF estimate with the true CSF; (2) how rapidly the stimulus%     selection algorithm excludes large regions of the stimulus space and%     focuses on the region of the stimulus space corresponding to the true%     CSF; (3) the aggregation of probability mass in the parameter space%     regions corresponding to the true CSF parameters; and (4) the convergence%     of the AULCSF error estimate towards 0%.% %        %      For a real experiment, it's not likely that you'll want to update%      the qCSF plots after each trial. Alternatively,  you can just plot%      at the very end. % %      Example: %      qcsf=runQCSF(qcsf,'plot experiment');%         	endsave('qCSF-experiment.mat','qcsf');    % saves the qcsf structure for later analysis. For your%                                 experiment or own simulations change the file name from 'qCSFDemo.mat'